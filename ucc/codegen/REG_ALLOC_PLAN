Here is how register allocation works.

Register Classes and Vertexes:

There are several register classes, rc, (depending on the machine architecture).
It is assumed that for any two rc's, either one is a subset of the other, or
they are completely disjoint.  So each rc has a set of subset rcs (which
generally includes itself).

Also, there may be more than one register class that map the same set of
registers.  In the AVR architecture, for example, "single" includes all
(single) registers, and "pair" includes all consecutive even and odd numbered
pairs of registers.  So every register belongs to both register classes.

To deal with this, "vertex" are used to represent register classes.  All
register classes mapping to the same set of registers are assigned to the same
vertex, and the subclass/superclass arrangements are between vertexes.  Thus,
generally where the term "register class" is used here, it generally actually
means "vertex".

Much of the allocation works with all subsets of an rc (including the rc
itself).  A "top down" order means going from superset to subset.  A "bottom
up" order means going from subset to superset.

Register Uses:

There are two kinds of register uses which compete for the same limited set of
registers:

    A.  Local variables (including parameters)
    B.  Temporary uses

Either of these may be "spilled" to memory if there are not enough registers
to go around.

Local Variable Register Use:

Local variables may be set and referenced any number of times.

Because we're not doing optimization, specifically live variable analysis, we
assume that all local variables require the register for the lifetime of the
function (unless they are spilled to memory).

The compiler examines all uses of the local variable to see if there is a
register class that is a common subset of the register class required for
each use.  IF so, the compiler assigns the local variable to that register
class.  If not, the compiler assigns the local variable to the register class
that works for the most uses (sets and references).

Temporary Register Use:

Temporary register uses start out associated with the output of a single
triple.  This always represents the sole definition in that register's use,
and is always the first use, or "head" of the register usage chain.

After that, there may be any number of references to the register spread across
time (these are currently limited to the same block, but that will change when
the optimizer is implemented).  These references are simply all of the
triple_parameters that link to this head triple as their parameter_id.

In addition, there may be points in the reference list where the rc changes --
these are indicated by the move_prior_to_needed or move_needed_to_next flags
in the triple_parameter.  The move_needed_to_parent flag indicates a brief need
to use some other rc.

If the register use is spilled, the copy to memory is always done at the
initial definition (the head).  This copy in memory may then be used at any
reference point, regardless of its rc.  But the data may remain valid for some
time in the register, so that copying the data from memory back to the register
each time it is referenced may not be needed (if a spill was not required
during that stretch of time).  Therefore, spilling a _reference_ in the
register usage always also spills the _head_; but not vice versa.

Algorithm:

/**** OLD
For each register use, try to allocate a place for it in the following order:

1.  Look for a free register, bottom up.  This does not increase the number of
registers the function needs, as it reuses a previously used register.

2.  Look for a super rc to bump, bottom up.  The "bottom up" refers the to the
subclasses of the rc being allocated, not the rc being bumped.  Bumping this
super rc may bump other, even more super rc uses or increase the number of
registers the function needs (in a super rc), but may not spill registers.

Note that to bump the super rc use, the period of time need for it must go
back to it's first use.  So steps 1 and 2 must be able to have a variable
start time (the use always goes up to the current time).

3.  Increase the number of registers the function needs, top down.

4.  Spill some other register.  This register could be in any subclass rc.
Spilling a subclass rc might also be useful to a wider range of later rc uses.
And also, picking a use to spill that goes further into the future might also
be useful to a wider range of later rc uses.  Which should take precedence is
not clear.
*****/

1.  Divide each line of register usage into segments terminating with each
    reference.  Each segment has a lifetime (start, end) starting at the
    previous decl/ref and ending at this reference.  Record the head of the
    line of register usage in each segment.

    Also create a segment for the head itself with start == end.

2.  If the function does not suspend, make a list of all of the local
    variables, setting the cost of each variable to the total number of
    definitions and uses (including the implicit definition in the call for
    parameters).  Sort this in increasing cost order.

    Also record the register class required by each local variable.

    Otherwise (if the function _does_ suspend), all locals will be allocated
    in memory (even though parameters are still passed in registers) and this
    list will be empty.

3.  Create an available number of registers for each vertex starting with the
    top-most superclass and working down recursively through the subclasses.
    The available number of registers is the total number of registers in the
    vertex including subclasses, minus the number of locals assigned to that
    vertex, including subclasses (not to exceed the number of registers in
    the subclass), minus the number of overflow locals from the superclass.
    (The assumption here is that there is at most one superclass for each
    vertex).

    The number of overflows, OV, to pass on to the subclasses is the number of
    registers in the vertex, excluding the subclasses, minus the number
    of locals in the vertex minus the number of overflow locals from
    the superclass.  Pick the OV lowest cost local vars in the union of the
    overflow locals from the superclass and locals for this register class,
    and store this list as the overflow locals for this vertex.

4.  At each point in time where there are more register segments than available
    registers, make an "overage list" of all of the segments at that point in
    time.  This point in time corresponds to the end time of one or more
    segments.

    When comparing each register class, include the segments from the
    subclasses and compare to the total number of available registers in the
    class calculated in step 3.

    Because of the multiple register classes, it is possible to have multiple
    overage lists for the same point in time (but for different register
    classes).  It is also possible for one segment to appear on more than
    overage list for the same point in time.  This shouldn't be a problem as
    long as the "double count rule", below, is observed.

    For each segment, A, in the overage list, store a count of the number of
    segments, B, also in the overage list, that are "fully contained" in A.
    B is fully contained in A iff A.start < B.start and A.end > B.end.

    "Double Count Rule":

        Do not count B more than once in A.count, even if both B and A appear
        together in multiple overage lists at the same point in time.

5.  Loop until there are no more overages:

    A.  Pick the segment, X, with the greatest count.  Break ties by
        picking the segment whose head has already been spilled.

        Note that it may be possible that the greatest count is 0.

    B.  Mark X and its head as being spilled.

    C.  Set X.count = 0.

    D.  Set X.start = X.end.

    E.  Delete X from each overage list, L, containing X, except for 
        overage lists (if any) corresponding to X.end.

        If there is an overage list for time X.end, add 1 to the count of each
        other segment in that list that didn't previously fully contain X.
        
        For each other list L:

            If the list no longer exceeds the maximum number of registers
            available:

                Decrement the counts associated with L for all segments in L.
                Note that the amount subtracted will be different for
                different segments.

                But do not decrement a count for segment B in segment A if B
                also appears with A in another overage list.

            Otherwise, for each segment, Y, in L, that fully contained X;
            decrement Y.count.

6.  Make a list of all the spills (including the heads).

7.  Taking the register classes in sets of siblings, bottom up:

    A.  For each sibling RC, make a list of spill chains, using the following
        for each spill chain.  The list of spill chains should end up in
        reverse cost order.

        a.  Select the spill from RC with the least end time, and create a
            chain with this as the only element.

        b.  While there are spills, S, in RC whose start > chain[-1].end:

            - append Sle, the spill in S with lowest end, to the chain.
            - remove Sle from the list of spills.

    B.  While overflow locals from parent RC.

        a.  Determine sibling RC that has the lowest cost for its first (most
            expensive) spill chain.  Call this RCs, and the cost, C.  If an
            RC's list of spill chains is empty, C is 0.

        b.  is cheapest overflow local cost > cost C from step a?

            1.  Yes.

                - spill the last (cheapest) spill chain in RCs (not the one
                  with cost C) and remove this from RCs' list of spill chains.

                - Find most expensive local, Le, in parent RC (including its
                  superclasses) and interchange this with the cheapest
                  overflow local.

                - Mark Le so that it will not be considered any more.

                - Remove the cheapest overflow local from the list of overflow
                  locals for the parent RC.

            2.  No.

                - spill the cheapest overflow local
                
                - remove it from the list of overflow locals for the parent RC.

                - mark the first spill chain in RCs (with cost C) as not
                  spilled and remove it from RCs' list of spill chains.

        c.  For each sibling RC, RC2, excluding RCs:

            - mark the first spill chain in RC2 as not spilled and remove it
              from RC2's list of spill chains.

    C.  For each sibling RC, RC1:

        a.  pair up the spill chains (in descending cost order) with the locals
            assigned to RC1 (in ascending cost order).

        b.  For all locals whose cost < their associated spill chain:

            - spill the local
            - assign the spill chain to the register used by local

8.  Assign a memory location to each spilled head each spilled local variable.

9.  Assign unspilled segments and locals to registers.

    Bottom up
    Match next segment to greatest prior end < next.start
