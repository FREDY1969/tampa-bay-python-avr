IntermediateCode is generated by the [Parse](ParsingAndCompiling#Parsing.md) phase.  It is a low-level machine independent representation of the program that is later optimized and converted into the assembler code for the target processor.

The IntermediateCode is made up of several tables stored in the [Database](Database.md):

  1. Blocks
  1. Triples
  1. Triple\_parameters
  1. Triple\_order\_constraints
  1. Triple\_labels

## Blocks ##

A block is a section of code that is only entered at the top and exited at the bottom.  It may not contain any branches into or out of the middle of the block.  If so, the block would need to be split into two smaller blocks to preserve the one entry, one exit rule.

Each block may end in one of three ways:

  1. By terminating the function (e.g., with a `return` or `raise` statement).
  1. With an unconditional jump to another block (e.g., the true block of an `if` statement jumps to the block following the `else` statement).
  1. With a conditional jump to one of two other blocks (e.g., the condition within the `if` statement jumps to either the true block or the false block).

Each block is made up of a set of triples.

## Triples ##

A triple represents a low-level machine-like, but machine independent, operation (like add, subtract, negate, compare) with zero or more operands.  Triples representing constant values or the contents of variables don't have any operands.  Triples representing operators have 1 or 2 operands, depending on the operator.  The only case for more than 2 operands is function calls, where the operands are the parameters to the function.  Thus, these operands can also be called _parameters_.  All operands are always simply other triples.

The triples carry the line number and column information taken from the AbstractSyntaxTree for error reporting and cross referencing.

Ignoring this line number and column information, the **triples** [Database](Database.md) table looks like:

| operator | int1 | int2 | string | notes |
|:---------|:-----|:-----|:-------|:------|
| 'input'  |  -   |  -   | port name | input data from a CPU I/O port |
| 'input-bit' | bit# | -    | port name | input one bit from a CPU I/O port |
| 'output' | triple id | -    | port name | output result of triple id to CPU I/O port |
| 'output-bit-set' | bit# | -    | port name | set bit in CPU I/O port |
| 'output-bit-clear' | bit# | -    | port name | clear bit in CPU I/O port |
| 'global\_addr' | symbol\_table id | -    | -      | address of global variable |
| 'global' | symbol\_table id | -    | -      | contents of global variable |
| 'local\_addr' | symbol\_table id | -    | -      | address of local variable |
| 'local'  | symbol\_table id | -    | -      | contents of local variable |
| 'int'    | value |  -   |   -    | integer constant |
| 'ratio'  | numerator | denominator | -      | ratio constant |
| 'approx' | number as int | binary pt | -      | actual number is int1 `*` 2<sup>int2</sup> |
| 'param'  | param# | triple id | -      | parameter in call to function |
| 'call\_direct' | symbol\_table id | -    | -      | normal function call |
| 'call\_indirect' | triple id | -    | -      | call function produced by triple |
| 'return' | optional triple id | -    | -      |       |
| 'if\_false' | condition triple id | -    | label  | if condition is false, branch to block named 'label', else fall through |
| 'if\_true' | condition triple id | -    | label  | if condition is true, branch to block named 'label', else fall through |
| operator | triple id | optional triple id | -      | apply operator to results of triple(s) |

## Triple\_parameters ##

The triples and their parameters form a directed acyclic graph (DAG) structure.  The compiler does common sub-expression elimination by linking the same triple as a parameter to more than one parent triple.

Thus, the linkage between parent triples and their parameter triples is a many-to-many relationship, which requires another database table called **triple\_parameters**.

## Triple\_order\_constraints ##

The DAG structure is used to give the compiler the freedom to choose the order of evaluation for the parameter triples that requires the least register usage.

But sometimes, there are ordering constraints the must be maintained in order to match the semantics of the language.  These ordering constraints are stored in the **triple\_order\_constraints** table.  These constraints place limits on the compiler's freedom to re-order the triples.

## Triple\_labels ##

Triples also have variables attached to them where the result of their execution must be stored.  These variables may be global variables, function arguments or local variables; but may not include subscripting.  (Subscripted assignment requires a special triple).

These variables are called _labels_ on the triple.

More than one variable may be attached to the same triple, so there is a many-to-one relationship between labels and triples, requiring a separate table called **triple\_labels**.